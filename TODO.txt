
authentication
	encrypt AES key with RSA key
	encryt entire authn_buf_t after AUTHN_STATUS_AES_SWAP_RESPONSE, yeah?
	finish new user status (including password)
	handle handoff from authn server to main server
		1-add authn_token member to structs node_t and node_buf_t
		2-if new user, add hashnode and node (with authn token, ip, port, fam, etc)
		3-if existing user, add node to corresponding hashnode (with authn token, ip, port, fam)
		4-for 2 & 3, move big chunk of code from main-server->STATUS_INIT_NODE to authn-server, yeah?
	handle new user vs existing user in ios app
	strlen + 1?
	delete items from keychain on app delete
	do we even need an AuthN token? I guess it verifies to the main server that we're authenticated, right? If the main server doesn't find a matching AuthN token in the corresponding hashnode->node, then it rejects that node, right?

fix bug where confirming chat port doesn't always work
self <=> get internal hole punching working
stay-in-touch with peers (and self nodes?)
new functionality:
	search for and add new contact + accept contact request
new ios functionality:
	messageTextField should move up and down with keyboard
	chatHistoryTextView should shrink and grow with keyboard + messageTextField
	recv msg in textview
	save chat history locally
	show chat history in textview

network encryption
	node-to-main-server (I think we can just encrypt and decrypt the entire struct node_buf_t)
	peer-to-peer (I think we can just encrypt and decrypt the entire struct node_buf_t)
	ACTUALLY, we can get rid of server-generated AES key: time-based reset of server AES IV... and notification to all nodes... once a day?
	ensure RSA swap request comes from Sup app (ie not from a fisher): maybe some sort of time-dependent key to pass with RSA swap


ffmpeg encryption or webrtc?
video_port
video server
POC video functionality

go back and use memcmp to compare all unsigned char arrays (i.e. ip6, etc)
thread the server
	recvfrom -> copy details (si_other, buf, etc) and handle in threadpool
thread wain et al

can we possibly put the in-memory structure in another program? if so, then we could stagger the server program and the memory program, which would allow us to change where the memory is run from without causing a disruption in service... i.e. start another memory program, wait for it to load up (copied from current memory program?), stop the server, and repoint the server to the new memory program... this might be a bad idea... but maybe a variation could help?

database

server host?
shrink node_buf, auth_buf, etc by converting to base64?

stress test in-memory data
	correct HASHSIZE AND AUTHN_HASHSIZE?

security
	server firewalls
	something else?

UDP-restricted firewall (STUN and TURN)

mvp app

APNs

test IPv6 somehow
valgrind (for client, try to use udp_client_test.c on linux)
create folder client-peer
clean up buttons and extraneous functions
get rid of node_min?
