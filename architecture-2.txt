postgres database - two tables
	users (username, password)
	contacts (username, contact_username)

The server never interacts directly with the database. Instead it CRUDs with the hashtable.

hashtable-users
	ht_node_t
		key = username
		value = linked list (node_t) of active IPs
		next

The hashtable contains all users, active or not. The hashtable is loaded on server start-up with all users from the db.users table.

For contacts, make a second hashtable-contacts that is loaded on server start-up from the db.contacts table. But instead of loading contact_username's into hashtable-contacts, load a pointer (ht_node_t) back to something in hashtable-users? The downside to this approach is that we are holding more pointers in memory. I think this is a very small downside. A pointer is 8 bytes. But if we have 100M users, with a 100 contacts each, that's 10B records -> 80B bytes -> 80M KB's -> 80K MB's -> 80GB's. With 1B users and 1K contacts each, that's 1T records -> 8T bytes -> 8B KB's -> 8M MB's -> 8K GB's. And how would this hashtable-contacts even be structured?

Or should we just add a double char pointer to ht_node_t called contacts? The downside to this approach is a possibly long lookup, and this lookup will occur often (i.e. every time a user signs in from a new device).

Rather than have a member on ht_node_t that indicates active/inactive, we simply check the value. If the value is NULL, then the user is inactive. Otherwise, the user is active.

Insertion:
	-New user: New ht_node_t => new active IP. Individual or batch update to db.user is fine since it is threaded and should not affect hashtable access.
	-New active IP: This is a normal put except that, if the ht_node_t already exists, we don't overwrite the value. We insert/put to the value, i.e. put to the linked list of active IPs.
	-New contact: We insert/put to the linked list in contact member.

Deletion/Disconnnection:
	-A peer can notify peers and server that it is disconnecting/closing, in which case we should delete the applicable node_t.
	-But we cannot rely soley on the peer to tell us this. What if the peer just loses an internet connection or someting?
	-We should delete the applicable node_t when the server doesn't receive a STATUS_STAY_IN_TOUCH message from that IP for a while. As the peers maintain a stay-in-touch status update as well, they can do the same thing.